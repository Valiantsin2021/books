import { resolve, dirname } from 'path'
import { fileURLToPath } from 'url'
import react from 'react'
import reactServer from 'react-dom/server.js'
import htm from 'htm'
import fastify from 'fastify'
import fastifyStatic from 'fastify-static'
import { StaticRouter } from 'react-router-dom'
import { App } from './frontend/App.js'

const __dirname = dirname(fileURLToPath(import.meta.url))
const html = htm.bind(react.createElement)

// Since we are not going to use the webpack dev server, we need to return the full HTML code of the page from our server.
// Here, we are defining the HTML template for all our pages using a function and a template literal. 
// We will be passing the result of our server-rendered React application as content to this template to get the final HTML to return to the client.
const template = ({ content }) => `<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>My library</title>
  </head>
  <body>
    <div id="root">${content}</div>
    <script type="text/javascript" src="/public/main.js"></script>
  </body>
</html>`

// we create a Fastify server instance and enable logging
const server = fastify({ logger: true })

// our web application will load the script /public/main.js. 
// This file is the frontend bundle that is generated by webpack. 
// Here, we are letting the Fastify server instance serve all static assets from the public folder using the fastify-static plugin.
server.register(fastifyStatic, { // ③
  root: resolve(__dirname, '..', 'public'),
  prefix: '/public/'
})

// In this line, we define a catch-all route for every GET request to the server. 
// The reason why we are doing a catch-all route is because the actual routing logic is already contained in the React application.
// When we render the React application, it will display the correct page component based on the current URL.
server.get('*', async (req, reply) => {
  const location = req.raw.originalUrl
  const staticContext = {}
  // On the server side, we have to use an instance of StaticRouter from react-router-dom and wrap our application component with it.
  // StaticRouter is a version of React Router that can be used for server-side rendering. 
  // This router, rather than taking the current URL from the browser window, allows us to pass the current URL directly from the server through the location prop.
  const serverApp = html` 
    <${StaticRouter}
      location=${location}
      context=${staticContext}
    >
      <${App}/>
    </>
  `
  // Here, we can finally generate the HTML code for our serverApp component by using React's renderToString() function. 
  // The generated HTML is the same as the one generated by the client-side application on a given URL. In the next few lines,
  //  we wrap this code with our page layout using the template() function and finally, we send the result to the client.
  const content = reactServer.renderToString(serverApp)
  const responseHtml = template({ content })

  let code = 200
  if (staticContext.statusCode) {
    code = staticContext.statusCode
  }

  reply.code(code).type('text/html').send(responseHtml)
})

// In the last few lines of code, we tell our Fastify server instance to listen on a given address and port defaulting to localhost:3000
const port = Number.parseInt(process.env.PORT) || 3000 // ⑦
const address = process.env.ADDRESS || '127.0.0.1'

server.listen(port, address, function (err) {
  if (err) {
    console.error(err)
    process.exit(1)
  }
})
